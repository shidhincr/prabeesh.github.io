<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Embedded | This is One of the Solutions]]></title>
  <link href="http://blog.prabeeshk.com/blog/categories/embedded/atom.xml" rel="self"/>
  <link href="http://blog.prabeeshk.com/"/>
  <updated>2015-04-09T23:43:00+05:30</updated>
  <id>http://blog.prabeeshk.com/</id>
  <author>
    <name><![CDATA[Prabeesh K]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Finding RC Constant Using ATmega8]]></title>
    <link href="http://blog.prabeeshk.com/blog/2012/07/14/finding-rc-constant-using-atmega8/"/>
    <updated>2012-07-14T23:39:00+05:30</updated>
    <id>http://blog.prabeeshk.com/blog/2012/07/14/finding-rc-constant-using-atmega8</id>
    <content type="html"><![CDATA[<p>The time constant(sec) of a RC circuit is equal to the product of the resistance and the capacitance of the circuit.</p>

<p>It is the time required to charge the capacitor through the resistor to 63. 2% of full charge,or to discharge it to 36.8% of its initial voltage.</p>

<p>The voltage of the RC circuit is measured using adc of the ATmega8, input voltage for RC circuit is given from PB0. The timer is start  at the time of the PB0 making 1 .</p>

<p>The adc of ATmega8(ADCH) is 8 bit long so corresponding to 5V get 255 in ADCH. The TCNT1 value is taken to a variable when the output voltage of the RC circuit become 63.2% of input voltage.That is  3.16 v corresponding to these voltage ADCH show 161(appr).</p>

<p>Using a LCD can show the TCNT1 value. TCNT1 is 16 bit long.Here ATmega8 running in 8MHz clock,timer prescaled by 1024.</p>

<p>So if you get the real time multiply the TCNT1 value to (1024/8000000).</p>

<p>Some test examples:
<code>
     R=1kΩ  C=100µF  the calculated RC constant is 0.1S.
</code>
The value of  TCNT1 is 846.Which is equal to 0.108288s.
<code>
     R=2kΩ  C=100µF  the calculated RC constant is 0.2S.
</code>
The value of  TCNT1 is 1864.Which is equal to 0.238592s.</p>

<pre><code class="c">
#include&lt;avr/io.h&gt;
#define F_CPU 8000000UL
#include &lt;util/delay.h&gt;

#define RS 6 //PD6
#define EN 7 //PD7
#define databits PORTC //PC0 to PC3
#define row1 cmd(0x80)
#define row2 cmd(0xc0)

void adc_init()
{
   //select AVCC reference voltage , left alignment of data and ADC4
   ADMUX=((1&lt;&lt;REFS0)|(1&lt;&lt;ADLAR)|(1&lt;&lt;MUX2));

   //enable ADC, set prescaler to divide the clock by 64 and auto triggering mode
   ADCSRA=((1&lt;&lt;ADEN)|(1&lt;&lt;ADFR)|(1&lt;&lt;ADPS2)|(1&lt;&lt;ADPS1)|(1&lt;&lt;ADPS0));

}

void conversion()
{
   //start conversion
   ADCSRA|=(1&lt;&lt;ADSC);
}

void port_init()
{
   DDRC = 0xcf;
   DDRD = (1 &lt;&lt; RS)|(1 &lt;&lt; EN);
}

void LCD_STROBE(void)
{
   PORTD |= (1 &lt;&lt; EN);
   _delay_us(1);
   PORTD &amp;= ~(1 &lt;&lt; EN);
}

void data(unsigned char c)
{
   PORTD |= (1 &lt;&lt; RS);
   _delay_us(50);
   databits = (c &gt;&gt; 4);
   LCD_STROBE();
   databits = (c);
   LCD_STROBE();
}

void cmd(unsigned char c)
{
   PORTD &amp;= ~(1 &lt;&lt; RS);
   _delay_us(50);
   databits = (c &gt;&gt; 4);
   LCD_STROBE();
   databits = (c);
   LCD_STROBE();
}

void clear(void)
{
   cmd(0x01);
   _delay_ms(5);
}

void lcd_init()
{
   _delay_ms(15);
   cmd(0x30);
   _delay_ms(1);
   cmd(0x30);
   _delay_us(100);
   cmd(0x30);
   cmd(0x28); // Function set (4-bit interface, 2 lines, 5*7Pixels)
   cmd(0x28); // Function set (4-bit interface, 2 lines, 5*7Pixels)
   cmd(0x0c); // Make cursorinvisible
   clear(); // Clear screen
   cmd(0x6); // Set entry Mode(auto increment of cursor)
}

void print(char *p)
{
   while(*p) data(*p++);
}

void main()
{
   char a[5],b[5];
   int c,d; 
   DDRB=0x01;
   _delay_ms(50);
   TCCR1B|=(1&lt;&lt;CS10)|(1&lt;&lt;CS12);//prescale 1024
   port_init();
   adc_init();
   lcd_init();
   PORTB=0x01;//applying vcc to RC circuit
   TCNT1=0x00;//start the timer

   while(1)
   { 
      conversion();

      while(!( ADIF));

      if(ADCH==161)//63% of the input voltage
      { 
         c=TCNT1; 
         d=ADCH;
         itoa(c,a,10);//integer to ASCII
         itoa(d,b,10);//integer to ASCII
         row1; 
         print(a);//showing timer value
         row2;
         print(b);//showing adc value
      }
   } 
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Running Arduino Codes in Stand Alone Atmega8]]></title>
    <link href="http://blog.prabeeshk.com/blog/2012/07/14/running-arduino-codes-in-stand-alone/"/>
    <updated>2012-07-14T02:23:00+05:30</updated>
    <id>http://blog.prabeeshk.com/blog/2012/07/14/running-arduino-codes-in-stand-alone</id>
    <content type="html"><![CDATA[<p>An Arduino board consists of an 8-bit Atmel AVR microcontroller with complementary components to facilitate programming and incorporation into other circuits.
If you wish to study the arduino codes ,then one of the major problems is the availability and cost of the Arduino board. If you have an atmega8 microcontroller  then you have to study the Arduino codes by simply changing some options in Arduino IDE.</p>

<p>First download the arduino IDE(I am using Arduino 1.0). Next you have to an avr  programmer(I am using usbasp and usbtiny).
Launch the arduino IDE as root.Then select your programmer from tools and also select your board  in this case select ATmega8.
Take care in fuse bytes because arduino codes are running in 8MHz.Y ou can enable internal 8MHz clock by</p>

<pre><code class="c">-U lfuse:w:0xa4:m -U hfuse:w:0xcc:m
</code></pre>

<p>Or you can enable the external crystal by setting the fuse byte as</p>

<pre><code class="c">-U lfuse:w:0xef:m
</code></pre>

<p>and put a  8MHz crystal.</p>

<p>You can find mapping between atmega8 and arduino here</p>

<p><img class="center" src="/images/arduino.png" width="600" height="350" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Simplest and Low Cost USB AVR Programmer USBtinyISP]]></title>
    <link href="http://blog.prabeeshk.com/blog/2012/07/04/simplest-and-low-cost-usb-avr/"/>
    <updated>2012-07-04T19:39:00+05:30</updated>
    <id>http://blog.prabeeshk.com/blog/2012/07/04/simplest-and-low-cost-usb-avr</id>
    <content type="html"><![CDATA[<p>This is the low cost AVR programmer using attiny2313. The schematic diagram is given below.</p>

<p><img class="center" src="/images/usbtiny_circuit.png" width="600" height="350" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>

<p>First setup the circuit as shown. Refer <a href="https://learn.adafruit.com/usbtinyisp">this site</a> for to burn program to this attiny 2313.</p>

<p>One important care taken to make fuse bit</p>

<pre><code class="c">avrdude -c usbasp -p t2313 -U hfuse:w:0xdf:m -U lfuse:w:0xef:m
</code></pre>

<p>If you use serial port to write the program , use stk200 command instead of usbasp.</p>

<p><img class="center" src="/images/040720129881.jpg" width="600" height="350" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>

<p><img class="center" src="/images/04072012989.jpg" width="600" height="350" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LCD Interfacing Using Msp430]]></title>
    <link href="http://blog.prabeeshk.com/blog/2012/07/04/lcd-interfacing-using-msp430/"/>
    <updated>2012-07-04T02:39:00+05:30</updated>
    <id>http://blog.prabeeshk.com/blog/2012/07/04/lcd-interfacing-using-msp430</id>
    <content type="html"><![CDATA[<p>There is a pot connect to the ADC of msp430 Ao(pin p1.0). The values  of  ADC10MEM displayed using LCD.</p>

<p>The Vcc for pot is taken from msp430 launchpad.so maximum voltage is 3.6v.</p>

<p>The msp430 10 bit ADC operates in the range 0 to 3.6V. If the input voltage is 0V,</p>

<p>the ADC generates a 10 bit value:</p>

<p>0 0 0 0 0 0 0 0 0 0</p>

<p>which is numerically equal to 0.</p>

<p>When the input voltage is 3.6V, the ADC</p>

<p>generates a 10 bit pattern:</p>

<p>1 1 1 1 1 1 1 1 1 1</p>

<p>which is numerically equal to 1023.</p>

<p>This values are stored in ADC10MEM.</p>

<p>The Vcc for LCD is given using another power supply of 5v.Because LCD display needed 5v for its functioning.</p>

<pre><code class="c">#include &lt;msp430.h&gt;

#define LCM_DIR P1DIR
#define LCM_OUT P1OUT

#define LCM_PIN_RS BIT2 // P1.2
#define LCM_PIN_EN BIT1 // P1.1
#define LCM_PIN_D7 BIT7 // P1.7
#define LCM_PIN_D6 BIT6 // P1.6
#define LCM_PIN_D5 BIT5 // P1.5
#define LCM_PIN_D4 BIT4 // P1.4
#define LCM_PIN_MASK ((LCM_PIN_RS | LCM_PIN_EN | LCM_PIN_D7 | LCM_PIN_D6 | LCM_PIN_D5 | LCM_PIN_D4))

#define FALSE 0
#define TRUE 1

//msp430 adc

void adc_init()

{
    ADC10CTL0 = ADC10ON | ADC10SHT_2 | SREF_0;
    ADC10CTL1 = INCH_0 | SHS_0 | ADC10DIV_0 | ADC10SSEL_0 | CONSEQ_0 ;
    ADC10AE0 = BIT0;
    ADC10CTL0 |= ENC ;
}

void start_conversion()

{
    ADC10CTL0 |= ADC10SC;
}

unsigned int converting()
{
    return ADC10CTL1 &amp; ADC10BUSY;
}

// MSP430 LCD Code
void PulseLcm()
{   
    // pull EN bit low  
    LCM_OUT &amp;= ~LCM_PIN_EN;
    __delay_cycles(200);
    // pull EN bit high 
    LCM_OUT |= LCM_PIN_EN;
    __delay_cycles(200);
    // pull EN bit low again    
    LCM_OUT &amp;= (~LCM_PIN_EN);
    __delay_cycles(200);
}

void SendByte(char ByteToSend, int IsData)
{
    // clear out all pins   
    LCM_OUT &amp;= (~LCM_PIN_MASK); 
    LCM_OUT |= (ByteToSend &amp; 0xF0); 

    if (IsData == TRUE)
    {
        LCM_OUT |= LCM_PIN_RS;
    }
    else
    {
        LCM_OUT &amp;= ~LCM_PIN_RS;
    }

    PulseLcm();
    LCM_OUT &amp;= (~LCM_PIN_MASK);
    LCM_OUT |= ((ByteToSend &amp; 0x0F) &lt;&lt; 4);  

    if (IsData == TRUE)
    {
        LCM_OUT |= LCM_PIN_RS;
    }
    else
    {
        LCM_OUT &amp;= ~LCM_PIN_RS;
    }   

    PulseLcm();
}

void LcmSetCursorPosition(char Row, char Col)
{
    char address;
    // construct address from (Row, Col) pair   

    if (Row == 0)
    {
        address = 0;
    }
    else
    {
        address = 0x40;
    }

    address |= Col;
    SendByte(0x80 | address, FALSE);
}

void ClearLcmScreen()
{
    // Clear display, return home
    SendByte(0x01, FALSE);
    SendByte(0x02, FALSE);
}

void InitializeLcm(void)
{
    LCM_DIR |= LCM_PIN_MASK;
    LCM_OUT &amp;= ~(LCM_PIN_MASK); 
    __delay_cycles(100000); 
    LCM_OUT &amp;= ~LCM_PIN_RS;
    LCM_OUT &amp;= ~LCM_PIN_EN; 
    LCM_OUT = 0x20;
    PulseLcm(); 
    SendByte(0x28, FALSE);  
    SendByte(0x0E, FALSE);  
    SendByte(0x06, FALSE);
}

void PrintStr(char *Text)
{
    char *c;
    c = Text;

    while ((c != 0) &amp;&amp; (*c != 0))
    {
        SendByte(*c, TRUE);
        c++;
    }
}

void main(void)
{
    adc_init(); 
    int i,a;    
    char b[5];  
    WDTCTL = WDTPW + WDTHOLD; // Stop watchdog timer    
    InitializeLcm();    

    while(1)
    {   

        start_conversion(); 
        while(converting());    
        a = ADC10MEM;   
        itoa(a,b,10);//integer to ASCII 
        ClearLcmScreen();   
        PrintStr(b);    
        for(i=0;i&lt;5000;i++);
    } 
}
</code></pre>

<p><div class="embed-video-container"><iframe src="//www.youtube.com/embed/hsM_o5hNUmg" allowfullscreen></iframe></div></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduction to AVR Programing]]></title>
    <link href="http://blog.prabeeshk.com/blog/2012/02/21/introduction-to-avr-programing/"/>
    <updated>2012-02-21T02:39:00+05:30</updated>
    <id>http://blog.prabeeshk.com/blog/2012/02/21/introduction-to-avr-programing</id>
    <content type="html"><![CDATA[<p>Atmel AVR 8-bit and 32-bit microcontrollers deliver a unique combination of performance, power efficiency, and design flexibility. Optimized to speed time to market, they are based on the industry’s most code-efficient architecture for C and assembly programming. No other microcontrollers deliver more computing performance with better power efficiency. Industry-leading development tools and design support let you get to market faster. Once there, the large AVR family lets you reuse your knowledge when improving your products and expanding to new markets—easily and cost-effectively.</p>

<p>package required in linux</p>

<p>binutils: Programs to manipulate binary and object files that may have been created for Atmel’s AVR architecture. This package is primarily for AVR developers and cross-compilers.</p>

<p>gcc-avr: The GNU C compiler, a fairly portable optimising compiler that supports multiple languages. This package includes C language support.</p>

<p>avr-libc: Standard library used for developing C programs for Atmel AVR microcontrollers. This package contains static libraries, as well as needed header files.</p>

<p>sample programe to blink  a LED</p>

<pre><code class="c">#include&lt;avr/io.h&gt;
#include&lt;util/delay.h&gt;
main()
{

        DDRC |=1&lt;&lt;PC2;  /* PC2 will now be the output pin */
        while(1)
        {
                PORTC &amp;= ~(1&lt;&lt;PC2);/* PC2 LOW */
               _delay_ms(10);
                PORTC |=(1&lt;&lt;PC2); /* PC2 HIGH */
               _delay_ms(10);
        }
}
</code></pre>

<p>save th above program to a file led.c</p>

<p>Then compile the program using avr-gcc and convert the c-code into object code as follows
<code>c
avr-gcc -mmcu=atmega8  led.c -o led.o
</code>
in next step convert the led.o object code to hex-code
<code>c
avr-objcopy -j .text -j .data -O  ihex  led.o  led.hex
</code>
in final step using USBASP we can write program  to avr
<code>c
avrdude -c usbasp -p m8 -U flash:w:led.hex:a
</code>
for more details about USBASP <a href="http://achuwilson.wordpress.com/2011/12/15/usbasp-a-usb-programmer-for-avr-microcontrollers/">visit</a></p>

<h4>Code Explanation</h4>

<p>The GNU C compiler for the Atmel family identifies all functional units within the microcontroller with meaningful names. Thus, writing `PORTC=0xff’ will result in the compiler generating machine code that writes 0xff to I/O port C, which will set all port C pins to logic high. Because ports are bidirectional, we must decide whether each pin should act as input or output. If the i’th bit of a register called DDRC (data direction register C) is 1, then the i’th pin of PORTC’s i’th pin will be an output. Otherwise, it will act as an input pin. (Note that pin and bit numbers start at zero.) To make an LED blink, you have to make a pin high, then low. (Here, we use PORTC’s 2nd port. That is, PC2 will be the 25th pin.) There should be a delay between the two. This is what the rest of the code does.</p>
]]></content>
  </entry>
  
</feed>
